package main

import (
	"context"
	"log"
	"net/http"
	"time"

	"connectrpc.com/connect"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	candlesv1 "hermeneutic-candles/gen/proto/candles/v1"        // generated by protoc-gen-go
	"hermeneutic-candles/gen/proto/candles/v1/candlesv1connect" // generated by protoc-gen-connect-go
)

type CandlesServer struct{}

func (s *CandlesServer) StreamCandles(
	ctx context.Context,
	req *connect.Request[candlesv1.StreamCandlesRequest],
	serverstream *connect.ServerStream[candlesv1.StreamCandlesResponse],
) error {
	ticker := time.NewTicker(time.Duration(req.Msg.Interval) * time.Second)
	defer ticker.Stop()

	// TODO:
	// Get the symbol and interval from the request
	// Query external CEXs
	go func() {
		for {
			select {
			case <-ctx.Done():
				return
			case t := <-ticker.C:
				// TODO: Use real data
				candle := &candlesv1.StreamCandlesResponse{
					Timestamp: time.Now().Unix(),
					Open:      float64(t.Second()),
					High:      float64(t.Second() + 1),
					Low:       float64(t.Second() - 1),
					Close:     float64(t.Second()),
					Volume:    float64(t.Second() * 10),
				}
				if err := serverstream.Send(candle); err != nil {
					// Log error and return, don't block
					log.Printf("failed to send candle: %v", err)
					return
				}
			}
		}
	}()

	<-ctx.Done()

	return nil
}

func main() {
	mux := http.NewServeMux()
	candlesService := &CandlesServer{}

	path, handler := candlesv1connect.NewCandlesServiceHandler(candlesService)
	mux.Handle(path, handler)

	server := &http.Server{
		// TODO: move to config file
		Addr:    ":8080",
		Handler: h2c.NewHandler(mux, &http2.Server{}),
	}

	log.Println("Starting server on :8080")
	if err := server.ListenAndServe(); err != nil {
		log.Fatalf("Failed to start server: %v", err)
	}
	log.Println("Server stopped")
}
